import React, { useRef, useEffect, useState } from 'react';
import * as THREE from 'three';

const TurnBasedGameArena = () => {
  const mountRef = useRef(null);
  const [selectedPieceType, setSelectedPieceType] = useState('party');
  const [boardSize, setBoardSize] = useState(8);
  const [pieces, setPieces] = useState([]);
  
  useEffect(() => {
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // Sky blue background
    
    // Camera setup
    const camera = new THREE.PerspectiveCamera(
      45, 
      mountRef.current.clientWidth / mountRef.current.clientHeight, 
      0.1, 
      1000
    );
    camera.position.set(boardSize * 0.8, boardSize * 0.8, boardSize * 0.8);
    camera.lookAt(boardSize / 2 - 0.5, 0, boardSize / 2 - 0.5);
    
    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
    mountRef.current.appendChild(renderer.domElement);
    
    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(boardSize, boardSize, boardSize);
    scene.add(directionalLight);
    
    // Create game board
    const boardGeometry = new THREE.BoxGeometry(boardSize, 0.5, boardSize);
    const boardMaterial = new THREE.MeshLambertMaterial({ color: 0x5d4037 }); // Brown board
    const board = new THREE.Mesh(boardGeometry, boardMaterial);
    board.position.set(boardSize / 2 - 0.5, -0.25, boardSize / 2 - 0.5);
    scene.add(board);
    
    // Create grid
    const gridHelper = new THREE.GridHelper(boardSize, boardSize);
    gridHelper.position.set(boardSize / 2 - 0.5, 0.01, boardSize / 2 - 0.5);
    scene.add(gridHelper);

    // Handle window resize
    const handleResize = () => {
      camera.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
    };
    
    window.addEventListener('resize', handleResize);
    
    // Mouse interaction setup
    const raycaster = new THREE.Raycaster();
    const clickMouse = new THREE.Vector2();
    
    const handleClick = (e) => {
      // Calculate mouse position
      const rect = renderer.domElement.getBoundingClientRect();
      clickMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      clickMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      
      // Cast ray
      raycaster.setFromCamera(clickMouse, camera);
      const intersects = raycaster.intersectObject(board);
      
      if (intersects.length > 0) {
        const point = intersects[0].point;
        // Convert to grid coordinates
        const x = Math.floor(point.x);
        const z = Math.floor(point.z);
        
        if (x >= 0 && x < boardSize && z >= 0 && z < boardSize) {
          // Add new piece
          const newPiece = {
            id: Date.now(), // Unique ID
            type: selectedPieceType,
            x: x,
            z: z
          };
          
          // Check if piece already exists at this position
          const existingPieceIndex = pieces.findIndex(p => p.x === x && p.z === z);
          
          if (existingPieceIndex !== -1) {
            // Replace existing piece
            const updatedPieces = [...pieces];
            updatedPieces[existingPieceIndex] = newPiece;
            setPieces(updatedPieces);
          } else {
            // Add new piece
            setPieces([...pieces, newPiece]);
          }
        }
      }
    };
    
    renderer.domElement.addEventListener('click', handleClick);
    
    // Animation loop
    const animate = () => {
      requestAnimationFrame(animate);
      
      // Rotate camera slowly
      camera.position.x = boardSize * 0.8 * Math.cos(Date.now() * 0.0001);
      camera.position.z = boardSize * 0.8 * Math.sin(Date.now() * 0.0001);
      camera.lookAt(boardSize / 2 - 0.5, 0, boardSize / 2 - 0.5);
      
      renderer.render(scene, camera);
    };
    
    animate();
    
    // Cleanup function
    return () => {
      window.removeEventListener('resize', handleResize);
      renderer.domElement.removeEventListener('click', handleClick);
      mountRef.current.removeChild(renderer.domElement);
    };
  }, [boardSize]); // Recreate scene when board size changes
  
  // Update pieces when they change
  useEffect(() => {
    if (!mountRef.current) return;
    
    // Get the scene
    const scene = mountRef.current.children[0].__r3f?.root.scene;
    if (!scene) return;
    
    // Remove all existing piece meshes
    scene.children.forEach(child => {
      if (child.userData.isPiece) {
        scene.remove(child);
      }
    });
    
    // Create new pieces
    pieces.forEach(piece => {
      let geometry, material;
      
      // Different shapes and colors for different piece types
      switch (piece.type) {
        case 'party':
          geometry = new THREE.CylinderGeometry(0.3, 0.3, 0.6, 32);
          material = new THREE.MeshLambertMaterial({ color: 0x4caf50 }); // Green
          break;
        case 'enemy':
          geometry = new THREE.ConeGeometry(0.3, 0.8, 32);
          material = new THREE.MeshLambertMaterial({ color: 0xf44336 }); // Red
          break;
        case 'neutral':
          geometry = new THREE.SphereGeometry(0.3, 32, 32);
          material = new THREE.MeshLambertMaterial({ color: 0xffeb3b }); // Yellow
          break;
        default:
          geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
          material = new THREE.MeshLambertMaterial({ color: 0x2196f3 }); // Blue
      }
      
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(piece.x + 0.5, 0.5, piece.z + 0.5);
      mesh.userData = { isPiece: true, id: piece.id };
      
      scene.add(mesh);
    });
    
  }, [pieces]);
  
  const handleClear = () => {
    setPieces([]);
  };
  
  const handleBoardSizeChange = (e) => {
    const newSize = parseInt(e.target.value, 10);
    setBoardSize(newSize);
    setPieces([]); // Clear pieces when resizing
  };
  
  return (
    <div className="flex flex-col items-center w-full">
      <div className="flex w-full justify-between p-4 bg-gray-100 mb-4 rounded-lg">
        <div className="flex items-center">
          <label className="mr-2 font-medium">Piece Type:</label>
          <select 
            value={selectedPieceType}
            onChange={(e) => setSelectedPieceType(e.target.value)}
            className="p-2 border rounded"
          >
            <option value="party">Party Member</option>
            <option value="enemy">Enemy</option>
            <option value="neutral">Neutral</option>
          </select>
        </div>
        <div className="flex items-center">
          <label className="mr-2 font-medium">Board Size:</label>
          <select 
            value={boardSize}
            onChange={handleBoardSizeChange}
            className="p-2 border rounded"
          >
            <option value="6">6x6</option>
            <option value="8">8x8</option>
            <option value="10">10x10</option>
            <option value="12">12x12</option>
          </select>
        </div>
        <button 
          onClick={handleClear}
          className="bg-red-500 text-white p-2 rounded hover:bg-red-600"
        >
          Clear Board
        </button>
      </div>
      
      <div className="relative w-full h-96 border rounded" ref={mountRef}>
        {/* Three.js will render here */}
      </div>
      
      <div className="mt-4 text-center">
        <p className="font-medium">Instructions:</p>
        <p>Click on the board to place a piece. The camera slowly rotates to show the 3D view.</p>
        <div className="mt-2 flex justify-center space-x-4">
          <div className="flex items-center">
            <div className="w-4 h-4 bg-green-500 rounded-full mr-1"></div>
            <span>Party Member</span>
          </div>
          <div className="flex items-center">
            <div className="w-4 h-4 bg-red-500 rounded-full mr-1"></div>
            <span>Enemy</span>
          </div>
          <div className="flex items-center">
            <div className="w-4 h-4 bg-yellow-500 rounded-full mr-1"></div>
            <span>Neutral</span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default TurnBasedGameArena;
